
;; ============= Custom Functions ===================
;; (defun in-l()
;;   (interactive)
;;   (if (evil-lispy-state-p)
;;       (message "in lispy state")
;;     (message "NOT in lispy state")))
(defun in-lispy ()
  (interactive)
  (if (evil-lispy-state-p)
      (hydra-buffer-menu/body)
    (self-insert-command)))
(defun collapse-expand ()
  (interactive)
  (hs-toggle-hiding)
  (beginning-of-line))
(defun my-remove-lispy-key (key)
  (define-key lispy-mode-map-base key nil)
  (define-key lispy-mode-map-lispy key nil)
  (define-key lispy-mode-map-oleh key nil)
  (define-key lispy-mode-map-paredit key nil)
  (define-key lispy-mode-map-special key nil))
(defun split-window-vertical-balance ()
  (interactive)
  (split-window-right)
  (balance-windows))
(defun delete-window-balance ()
  (interactive)
  (delete-window)
  (balance-windows))
(defun split-window-below-balance ()
  (interactive)
  (split-window-below)
  (balance-windows))
(defun transpose-windows ()
  "Transpose two windows.  If more or less than two windows are visible, error."
  (interactive)
  (unless (= 2 (count-windows))
    (error "There are not 2 windows."))
  (let* ((windows (window-list))
         (w1 (car windows))
         (w2 (nth 1 windows))
         (w1b (window-buffer w1))
         (w2b (window-buffer w2)))
    (set-window-buffer w1 w2b)
    (set-window-buffer w2 w1b)))
;; (defun lispy-append ()
;;   (interactive)
;;   (forward-char)
;;   (evil-lispy-state))
(defun lispy-parens-from-normal ()
  (interactive)
  (evil-lispy-state)
  (lispy-parens)
  (call-interactively #'evil-lispy/enter-state-left))
(defun load-ns-goto-repl ()
  "Since cider-load-buffer is already an interactive function
must call with: call-interactively in order to not exit after
function call."
  (interactive)
  (call-interactively #'cider-load-buffer)
  (call-interactively #'cider-repl-set-ns)
  (call-interactively #'cider-switch-to-repl-buffer))
(defun o-lispy ()
  (interactive)
  (evil-open-below 1)
  (call-interactively #'evil-lispy-state))
(defun O-lispy ()
  (interactive)
  (evil-open-above 1)
  (call-interactively #'evil-lispy-state))
(defun a-lispy ()
  (interactive)
  (evil-append 1)
  (call-interactively #'evil-lispy-state))
(defun A-lispy ()
  (interactive)
  (evil-append-line 1)
  (call-interactively #'evil-lispy-state))
(defun I-lispy ()
  (interactive)
  (evil-insert-line 1)
  (call-interactively #'evil-lispy-state))
(defun ielm-auto-complete ()
  "Enables `auto-complete' support in \\[ielm]."
  (setq ac-sources '(ac-source-functions
                     ac-source-variables
                     ac-source-features
                     ac-source-symbols
                     ac-source-words-in-same-mode-buffers))
  (add-to-list 'ac-modes 'inferior-emacs-lisp-mode)
  (auto-complete-mode 1))
(defun eval-sexp-print-in-comment ()
  (interactive)
  (cider-eval-print-last-sexp)
  (beginning-of-line)
  (insert ";; =>  "))
;; (clomacs-defun adder (+ 1 1))
;; (message (adder))
(defun lispy-right-p ()
  "Return t if after lispy-right character."
  (looking-back "[])}]"
                (line-beginning-position)))
(defun lispy-left-p ()
  "Return t if on lispy-left character."
  (looking-at "[([{]"))
(defun in-special-p ()
  (and (evil-lispy-state-p)
       (or (lispy-right-p) (lispy-left-p))))
(defun e-clojure ()
  "call cider-eval-last-sexp when in special position"
  (interactive)
  (if (in-special-p)
      (cider-eval-last-sexp)
    (self-insert-command 1)))
(defun e-lisp ()
  "call eval-last-sexp if in special position"
  (interactive)
  (if (in-special-p)
      (call-interactively #'eval-last-sexp)
    (self-insert-command 1)))
(defun query-replace-symbol-at-point (inp)
  "jumps to top of file to start the replacing...eeek, dont like
that."
  (interactive
   (let ((symb-at-pt (thing-at-point 'symbol)))
     (list (read-string (format "Replace %s with: " symb-at-pt) nil 'my-history))))
  (let ((symb-at-pt (thing-at-point 'symbol)))
    (query-replace symb-at-pt inp t (line-beginning-position) (point-max))))
(defun at-beginning-of-line-p ()
  (interactive)
  (= (point) (line-beginning-position)))
(defun eval-sexp-or-buffer ()
  (interactive)
  (if (at-beginning-of-line-p)
      (eval-buffer)

    (call-interactively #'eval-defun)))
(defun current-line-empty-p ()
  (save-excursion
    (beginning-of-line)
    (looking-at "[[:space:]]*$")))
(defun char-after-i () (interactive)
       (message "char after is: %s" (char-after)))
(defun top-level-sexp-p () (interactive)
       (and (= 40 (char-after))
            (= 0 (current-column)))) 
(defun goto-top-level-sexp ()
  "go to the beginning of the current defun"
  (interactive)
  (if (not (top-level-sexp-p))
      (beginning-of-defun)))
(defun forward-parent-sexp ()
  (interactive)
  (goto-top-level-sexp)
  (call-interactively #'lispy-down))
(defun backward-parent-sexp ()
  (interactive)
  (goto-top-level-sexp)
  (call-interactively #'lispy-up))
(defun insert-space-around-sexp ()
  (interactive)
  (save-excursion
    (goto-top-level-sexp)
    (forward-line -1)
    (if (not (current-line-empty-p))
        (progn
          (forward-line 1)
          (open-line 1))
      (forward-line 1)))
  (save-excursion
    (end-of-defun)
    (if (not (current-line-empty-p))
        (progn
          (open-line 1)))))
(defun forward-search-syombol-at-point ()
  "search forward the symbol at point (under the cursor)"
  (interactive)
  (let ((symb-at-pt (thing-at-point 'symbol)))
    (search-forward symb-at-pt)))
(defun end-of-parent-sexp ()
  (interactive)
  (evil-lispy/enter-state-left)
  (special-lispy-beginning-of-defun)
  (o-lispy))
(defun first-open-paren ()
  (interactive)
  (search-forward "(")
  (backward-char)
  (call-interactively #'evil-lispy/enter-state-left))
(defun repl-reload-ns ()
  "Thin wrapper around `cider-test-run-tests'."
  (interactive)
  (when (cider-connected-p)
    (let ((cider-auto-select-test-report-buffer nil)
          (cider-test-show-report-on-success nil))
      (cider-repl-set-ns
       (cider-current-ns))
      (cider-ns-reload))))
(defun load-buffer-set-ns ()
  (interactive)
  (call-interactively #'cider-load-buffer)
  (call-interactively #'repl-reload-ns))
;; write a defun that opens the corresponding test file
;; clojure-find-ns -> reports the current clojure buffer ns
(defun open-test-file ()
  "open the corresponding test file to this implementation file"
  (interactive)
  (let*
      ((no-dash-ns (replace-regexp-in-string "-" "_" (clojure-find-ns)))
       (no-dot-ns (replace-regexp-in-string (regexp-quote ".") "/" no-dash-ns))
       (file-extension (file-name-extension (buffer-file-name)))
       (test-file (concat (projectile-project-root) "test/" no-dot-ns "_test." file-extension)))
    (find-file test-file)))
(defun open-impl-file ()
  "open the corresponding implementation file for this test file."
  (interactive)
  (let*
      ((no-test-ns (replace-regexp-in-string "-test" "" (clojure-find-ns)))
       (no-dash-ns (replace-regexp-in-string "-" "_" no-test-ns))
       (no-dot-ns (replace-regexp-in-string (regexp-quote ".") "/" no-dash-ns))
       (file-extension (file-name-extension (buffer-file-name)))
       (impl-file (concat (projectile-project-root) "src/" no-dot-ns "." file-extension)))
    (find-file impl-file)))
(defun get-curr-function-name ()
  (save-excursion
    (goto-top-level-sexp)
    (forward-word)
    (forward-char)
    (thing-at-point 'symbol)))
(defun remove-test-suffix (test-name)
  (replace-regexp-in-string "-tests" "" test-name))
(defun go-to-test-function ()
  "go to test definition file and goto first test that tests the
function that you are currently in/on.  test functions should be
named <function-under-test-name>-<some number>-test"
  (interactive)
  (let ((curr-fn-name (get-curr-function-name)))
    (open-test-file)
    (goto-char (point-min))
    (search-forward (concat "deftest " curr-fn-name))))
(defun go-to-impl-function ()
  "when you are in a test function that is named appropriately,
find the corresponding function that this test is testing.  test
functions should be named <function-under-test-name>-<some
number>-test"
  (interactive)
  (let* ((curr-fn-name (get-curr-function-name))
         (curr-fn-name-no-suffix (remove-test-suffix curr-fn-name)))
    (open-impl-file)
    (goto-char (point-min))
    (search-forward (concat "defn " curr-fn-name-no-suffix))))
(defun in-test-file-p ()
  "true/false predicate if in a test file."
  (let ((pref (concat (projectile-project-root) "test/"))
        (buf (buffer-file-name)))
    (string-prefix-p pref buf)))
(defun set-plist! (plist key value)
  (setq plist (plist-put plist key value)))

(defun project-relative-path ()
  (interactive)
  (let* ((plst '())
         (buf-name (buffer-name))
         (projectile-file-p (string-prefix-p pr buf))
         (file-name (buffer-file-name))
         (projectile-root (projectile-project-root))
         )
    (set-plist plst 'projectile-root projectile-root)
    (set-plist plst 'file-name file-name)
    (set-plist plst 'projectile-file-p projectile-file-p)
    (set-plist plst 'buffer-name buf-name)
    (set-plist plst 'in-repl-p (string-prefix-p "*cider-repl " buf-name))
    ;; (set-plist plst)
;; http://ergoemacs.org/emacs/elisp_property_list.html  
    
    
    (if proj-file-p
        (substring buf (length pr))
      nil)
    plst))

(defun in-repl-p ()
  (let* ((buf-name (buffer-name)))
    (string-prefix-p "*cider-repl " buf-name)))
(defun in-file-of-type ()
  (interactive)
  (cond
   ((in-repl-p) 'repl)
   ((in-test-file-p) 'test-file)
   (t 'source-file)))
(defun ifot ()
  (interactive)
  (pcase (in-file-of-type)
    ('repl (message "in repl"))
    ('test-file (message "test file"))
    ('source-file (message "source file"))
    (otherwise (message "Unknown file type %S" otherwise))))
(defun toggle-goto-test-impl ()
  (interactive)
  (if (in-test-file-p)
      (go-to-impl-function)
    (go-to-test-function)))
(defun goto-last-clojure-file ()
  (interactive)
  (if (in-test-file-p)
      toggle-goto-test-impl)
  ()
  )
(defun goto-clojure-spec-file ()
  (interactive)
  (let* ((ns
          (if (in-test-file-p)
              toggle-goto-test-impl))))
  (if (in-test-file-p)
      toggle-goto-test-impl))
(defun find-clojure-ns ()
  (interactive)
  (message "cloj ns: %s" (clojure-find-ns)))
